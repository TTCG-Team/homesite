import{b as i}from"./index.browser.esm.-7-YfEcu.js";function c(n,e){if(!n)throw new Error("assert "+e)}class g{constructor(e,t){this.size=e,this.name=t}getSize(e){return this.size}encode(e,t){return e.copy(t,0)}decode(e){return[i.Buffer.from(e.slice(0,this.size)),this.size]}}class d{constructor(e){this.name=e}getSize(e){return e?4+e.length:4}encode(e,t){return e?(t.writeUInt32LE(e.length),e.copy(t,4),4+e.length):(t.writeUInt32LE(0),4)}decode(e){const t=e.readUInt32LE();return t==0?[i.Buffer.from([]),4]:[i.Buffer.from(e.slice(4,4+t)),4+t]}}class h{constructor(e){this.name=e,this.l=new d(e)}l;getSize(e){return this.l.getSize(this.encode_to_buffer(e))}encode(e,t){return this.l.encode(this.encode_to_buffer(e),t)}decode(e){const[t,r]=this.l.decode(e);return[this.decode_from_buffer(t),r]}}class _ extends h{encode_to_buffer(e){return i.Buffer.from(e)}decode_from_buffer(e){return e.toString()}}class f{constructor(e){this.name=e}getSize(e){return 1}encode(e,t){if(e>255)throw new Error(`u8 plug ${this.name} encode error, value must in [0, 255], but got ${e}`);return t.set([e],0),1}decode(e){return c(e.length>0),[e.at(0),1]}}class y{constructor(e){this.name=e}getSize(e){return 1}encode(e,t){return t.set([e?1:0],0),1}decode(e){return c(e.length>0),[!!e.at(0),1]}}class w{constructor(e){this.name=e}getSize(e){return 8}encode(e,t){return t.writeBigUint64LE(BigInt(e)),8}decode(e){c(e.length>=8);let t=e.readBigUInt64LE();return[Number(t),8]}}class z extends f{constructor(e,t){super(t),this.v=e,this.name=t}encode(e,t){return this.v!==e&&console.warn(`const u8 layout is ${this.v}, the input value ${e} will be ignored.`),super.encode(this.v,t)}decode(e){const[t,r]=super.decode(e);return this.v!==t&&console.warn(`const u8 layout is ${this.v}, the decoded value ${t} will be ignored.`),[this.v,1]}}class L{constructor(e,t){this.layout_arr=e,this.name=t}getSize(e){let t=0;for(let r=0;r<this.layout_arr.length;r++){const o=this.layout_arr[r];if(o.name){const s=o.getSize(e[o.name]);t+=s}else throw new Error("unnamed layout")}return t}encode(e,t){let r=0;for(let o=0;o<this.layout_arr.length;o++){const s=this.layout_arr[o];if(s.name){const u=s.encode(e[s.name],t);r+=u,t=t.slice(u)}else throw new Error("unnamed layout")}return r}decode(e){const t={};let r=0;for(let o=0,s=e;o<this.layout_arr.length;o++){const u=this.layout_arr[o];if(u.name){const[a,l]=u.decode(s);t[u.name]=a,s=s.slice(l),r+=l}else throw new Error("unnamed layout")}return[t,r]}}function p(n,e){const t=e.getSize(n),r=i.Buffer.alloc(t),o=e.encode(n,r);return c(t==o,`encoded length must equel to calculated size.size: ${t}, len: ${o}`),r}function S(n,e){const[t,r]=e.decode(n);return c(n.length==r,"decoded length must equal to input buffer length."),t}export{y as B,z as C,g as F,L as O,_ as S,w as U,c as a,p,S as u};
